# Rust Specialist Agent Configuration
# Advanced Rust development analysis with ownership, async, and performance focus

agent:
  name: "rust-specialist"
  version: "1.0.0"
  description: "Advanced Rust development specialist with ownership and performance expertise"

  # Model selection strategy - Rust requires complex reasoning
  model_preference:
    primary: "claude-opus-4-1"      # Complex ownership/lifetime analysis
    fallback: "claude-sonnet-4-0"   # Standard code analysis
    simple_tasks: "claude-3-5-haiku-latest"  # Basic syntax checks

  complexity_routing:
    high_complexity: "opus-4-1"     # Ownership analysis, lifetime conflicts
    medium_complexity: "sonnet-4-0" # Code patterns, performance analysis
    low_complexity: "haiku-latest"     # Syntax checks, formatting

  cost_optimization:
    prefer_cheaper: false        # Rust analysis benefits from Opus reasoning
    fallback_on_rate_limit: true
    budget_cap_per_hour: 100     # Dollar limit

# Core analysis settings
analysis:
  default_analysis_type: "full"  # full, ownership, async, performance, clippy

  # Ownership and borrowing analysis
  ownership:
    check_moves: true
    analyze_lifetimes: true
    detect_memory_leaks: true
    suggest_smart_pointers: true
    check_send_sync: true

  # Code quality thresholds
  quality_metrics:
    max_cyclomatic_complexity: 8   # Rust prefers smaller functions
    max_function_length: 40        # Due to ownership complexity
    max_file_length: 500
    min_test_coverage: 85          # High standards for memory safety
    max_unsafe_blocks: 5           # Limit unsafe code

  # Clippy configuration
  clippy:
    warn_all: true
    warn_pedantic: true
    warn_nursery: true
    warn_cargo: true
    deny_unsafe_op_in_unsafe_fn: true
    allow_patterns: []             # Customizable allow list

# Error handling configuration
error_handling:
  prefer_result_over_panic: true
  require_error_context: true
  suggest_custom_error_types: true

  error_libraries:
    anyhow: "context and error chaining"
    thiserror: "custom error types"
    eyre: "error reporting with spans"

  patterns:
    use_question_operator: true
    prefer_early_return: true
    require_error_documentation: true

# Async programming settings
async_programming:
  default_runtime: "tokio"  # tokio, async-std, smol

  tokio:
    features: ["full"]
    version_constraint: ">=1.0"
    multi_threaded: true

  patterns:
    prefer_spawn_over_block: true
    check_blocking_calls: true
    analyze_backpressure: true
    suggest_stream_processing: true
    check_select_fairness: true

  performance:
    max_concurrent_tasks: 1000
    warn_expensive_clones: true
    suggest_arc_over_rc: true

# Cargo and dependency management
cargo:
  workspace_analysis: true
  feature_optimization: true

  dependencies:
    check_outdated: true
    security_audit: true
    license_compliance: true
    suggest_alternatives: true

  build_optimization:
    profile_optimization: true
    lto_suggestions: true
    target_cpu_optimization: true
    panic_strategy_analysis: true

  features:
    default_features: false        # Prefer explicit features
    suggest_feature_gates: true
    analyze_feature_combinations: true

# Performance analysis settings
performance:
  profiling:
    suggest_flamegraph: true
    check_allocation_patterns: true
    analyze_iteration_efficiency: true

  optimizations:
    suggest_simd: true
    check_branch_prediction: true
    analyze_cache_locality: true
    suggest_const_generics: true

  benchmarking:
    suggest_criterion: true
    identify_benchmark_targets: true
    performance_regression_detection: true

# Memory safety and security
safety:
  unsafe_code:
    require_documentation: true
    suggest_safe_alternatives: true
    check_soundness_holes: true

  security:
    check_input_validation: true
    analyze_integer_overflow: true
    detect_timing_attacks: true
    suggest_constant_time: true

# Testing configuration
testing:
  frameworks:
    unit_tests: "built-in"
    property_tests: "proptest"
    fuzzing: "cargo-fuzz"
    benchmarks: "criterion"

  patterns:
    test_organization: "inline"  # inline, separate
    mock_strategy: "mockall"
    async_testing: "tokio-test"

  coverage:
    tool: "tarpaulin"
    threshold: 85
    exclude_patterns: ["tests/", "benches/"]

# Synapse integration settings
synapse:
  enabled: true
  auto_activate: true

  search_patterns:
    ownership_patterns: "rust ownership borrowing {type} {context} memory safety"
    async_patterns: "rust async tokio {pattern} {context} concurrency"
    error_patterns: "rust error handling {pattern} result option anyhow"
    performance_patterns: "rust performance optimization {pattern} {context}"

  cache_settings:
    enable_cache: true
    cache_ttl: 3600      # 1 hour
    max_cache_size: 150  # MB

  knowledge_domains:
    - "rust-ownership"
    - "rust-async"
    - "rust-performance"
    - "rust-error-handling"
    - "cargo-ecosystem"
    - "rust-testing"

# Performance and resource limits
performance_limits:
  max_concurrent_analyses: 3     # Rust analysis is CPU intensive
  analysis_timeout: 600          # 10 minutes for complex ownership analysis
  max_file_size_mb: 5
  max_project_files: 500

  memory_limits:
    heap_size_mb: 1024
    ast_cache_size_mb: 200

# Collaboration settings
collaboration:
  inter_agent_timeout: 45       # Longer timeout for complex analysis
  max_collaborative_tasks: 2

  preferred_agents:
    code_review: "code-hound"
    testing: "test-runner"
    documentation: "docs-writer"
    architecture: "architect"
    security: "security-specialist"

  communication:
    log_interactions: true
    retry_failed_requests: 2
    request_timeout: 30

# Development and debugging
development:
  debug_mode: false
  verbose_logging: false
  save_analysis_reports: true

  rust_specific:
    cargo_check_on_analysis: true
    clippy_integration: true
    rustfmt_validation: true

  mock_integrations:
    synapse: false  # Use real Synapse unless unavailable
    cargo_commands: false

  experimental_features:
    ai_assisted_refactoring: true
    ownership_inference: true
    performance_profiling: true
    unsafe_code_analysis: true

# Rust ecosystem integration
ecosystem:
  crates_io:
    check_popularity: true
    suggest_alternatives: true
    check_maintenance: true

  tooling:
    rustup: true
    cargo_expand: true
    cargo_asm: true
    cargo_audit: true
    cargo_deny: true

  targets:
    cross_compilation: ["x86_64-unknown-linux-gnu", "aarch64-apple-darwin"]
    no_std_support: true
    wasm_support: true

# Environment overrides
environment:
  development:
    debug_mode: true
    mock_integrations: true
    analysis_timeout: 120

  ci:
    performance_monitoring: true
    detailed_reporting: true

  production:
    debug_mode: false
    performance_monitoring: true
    strict_analysis: true